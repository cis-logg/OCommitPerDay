메모리 읽기
프로그램 처리량은 메모리 접근 속도에 종속적이다. 

대기상태 : 낭비되는 클럭 사이클
클럭사이클 : 클럭 신호가 높은 전압에서 낮은 전압으로 변할 때 시작 = 하강 에지

cache memory : 일반 메모리는 CPU보다 훨씬 느려 가장 최근에 사용한 명령어와 데이터를 저장하기 위해 사용한다.
cache hit : 데이터가 캐시에 있다.
cache miss : 데이터가 캐시에 없어 일반 메모리에서 읽어야 한다.

프로그램 실행 방법
1. OS는 프로그램 현재 디스크 디렉토리에서 파일 이름을 검색한다.
   찾을 수 없으면 path(미리 정해놓은 목록의 디렉토리)에서 찾는다.
   못 찾으면 오류 메시지 
2. 프로그램을 찾은 후 OS는 디스크 디렉토리에서 파일 크기와 디스크 드라이브의 
   물리적 위치를 포함하는 프로그램 파일에 대한 기본 정보를 얻는다.
3. OS는 메모리의 사용 가능한 다음 위치를 결정, 프로그램 파일을 메모리로 적재한다.
   
4. OS는 프로그램에 메모리 블록을 할당, 프로그램 크기와 위치에 대한 정보를 (때때로 서술자 테이블이라고 부르는)
   테이블에 넣는다. 
   추가로 OS는 프로그램 내의 포인터들이 프로그램 데이터의 주소를 포함하도록 포인터의 값을 조정할 수도 있다.
5. OS는 프로그램의 첫 번째 기계어 명령어의 실행을 시작.
   실행된 프로그램 = process
   OS는 process에 process ID를 부여한다.
6. process는 스스로 실행한다.
   실행을 추적, 시스템 자원에 대한 요청에 응답하는 것은 OS의 일이다. (메모리, 디스크 파일, 입출력 장치)
7. process가 끝날 때에 메몰에서 제거된다.

멀티태스킹
동시에 여러 개의 작업을 실행할 수 있다.
task는 프로그램(process)나 실행 thread로서 정의된다. 
process는 자신의 메모리 영역을 가지며 여러 개의 thread를 포함한다.
thread는 같은 process에 속한 다른 thread와 메모리를 공유한다.

CPU는 실제로 한 번에 하나의 명령어만 실행 
= scheduler라고 하는 운영체제의 구성요소가 time slice라고 불리는 CPU 시간의 조각을 각 task에 할당한다.
ex) round-robin scheduling

멀티태스킹 OS는 task switching을 지원하는 프로세서에서 실행
전환되기 전에 각 task상태를 저장한다. 
task 상태 : 태스크 메모리 세그먼트에 대한 참조, 프로세서 레지스터, 프로그램 카운터, 상태 플래그 구성

